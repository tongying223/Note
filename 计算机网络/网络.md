# 网络

## 一 OSI与TCP/IP

![äºå±ä½ç³»ç»æ](https://gitee.com/tongying003/MapDapot/raw/master/img/20200505180731.png)

### 1.1 物理层

在物理层上所传输的数据单位是`比特`。**物理层（physical layer）的作用是实现相邻计算机结点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异**。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传输比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的

### 1.2 数据链路层

**数据链路层（data link layer）通常称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。**在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成`帧`，在相邻结点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。

在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。



### 1.3 网络层

**在计算机网络中进行通信的两个计算机之间可以经过很多个数据链路，也可能还需要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。**在发送数据时，网路层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫`IP数据报`，简称`数据报`。

互联网是由大量异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocl）和许多路由选择协议，因此互联网的网路层也叫网际层或IP层



### 1.4 运输层

**运输层（transport layer）的主要任务是负责向两台主机进程之间的通信提供通用的数据传输服务。**应用进程利用该服务传输应用层报文。“通用的”是指并不针对某一个特定的网路应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个进程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。



**运输层主要使用以下两种协议：**

（1）**传输控制协议TCP（Transmission Control Protocol）**：提供**面向连接的**，**可靠的**数据传输服务

（2）**用户数据报协议UDP（User Datagram Protocal）**：提供**无连接的**，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）



### 1.5 应用层

**应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议，在互联网中应用层协议很多，如**域名系统DNS**，支持万维网应用的**HTTP协议**，支持电子邮件的**SMTP协议**等等，我们把应用层交互的数据单元称为报文。



**域名系统**

```
域名系统（Domain Name System缩写DNS，Domain Name被译作域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人们更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。例如：一个公司的Web网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如IBM的域名www.ibm.com
```



**HTTP协议**

```
超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最广泛的一种网络协议。所有的www（万维网）文件都必须遵守这个标准。设计HTTP最初的目的是提供一种发布和接收HTML页面的方法。
```

![ä¸å±ä½ç³»ç»æå¾](https://gitee.com/tongying003/MapDapot/raw/master/img/20200505180742.png)



## 二 三次握手与四次挥手

### 2.1 传输控制协议TCP

1. 面向连接的、可靠的、基于字节流的传输层通信协议
2. 将应用层的数据流分割成报文段并发送给目标结点的TCP层
3. 数据包都有序号，对方收到则发送ACK确认，未收到则重传
4. 使用校验和来检验数据在传输过程中是否有误



### 2.2 TCP报文头

![è¿éåå¾çæè¿°](https://gitee.com/tongying003/MapDapot/raw/master/img/20200505180748.jpeg)

- #### 源端口（`Source Port`）和目的端口（`Destination Port`）

  分别占用16字节，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同主机的，源端口号和目的端口号配合上IP首部中的IP地址和目的IP地址就能唯一确定一个TCP连接。

- #### 序列号（`Sequence Number`）

  用来标识从TCP发送端向TCP接收端发送的数据字节流，它表示在这个报文段中的第一个数据字节在数据流中的序号，主要用来解决网络报乱序的问题。

- #### 确认号（`Acknowledement Number`）

  32位确认序号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应该是上次已成功收到数据字节序号+1，不过，只有当标志位中的ACK标志为1时该确认序号的字段才有效。主要用来解决不丢包的问题

- #### 头部长度（`Offset`）

  给出首部中32bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段战4bit（最多表示15个32bit的字，即60byte的首部长度），因此TCP最多有60字节的首部。若没有任选字段，TCP报文头的最小长度是20byte

- #### 标志位（`TCP Flags`）

  TCP首部中有6个标志位，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG、ACK、PSH、RST、SYN、FIN。每个标志位的意思如下：

  ```
  URG:表示TCP包的紧急指针域有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据
  
  ACK:确认序号标志。ACK=1表示应答域有效
  
  PSH:表示Push指针。Push操作是指在数据包达到接收端以后，立即传送给应用程序，而不是在缓冲区中排队
  
  RST:复位请求。用来复位那些产生错误的连接，也用来拒绝错误和非法的数据包。
  
  SYN:表示同步序号，用来建立连接。
  
  FIN:finish标志，用于释放连接。
  ```

- #### 窗口大小（`window`）

  接收窗口的大小，用于TCP流量控制

- #### 校验和（`Checksum`）

  16位。发送端基于数据内容计算一个数值，接收端要与发送端数值结果完全一致，才能证明数据的有效性。

- #### 紧急指针（`Urgent Poniter`）

  仅当URG=1有效，指出报文段中紧急字段的长度



### 2.3 TCP三次握手

![z](assets/1641067-8d52ca990ffbee0a.webp)

```
第一次握手：客户端发送一个SYN包(seq=x)到服务器，并进入SYN_SENT状态，等待服务端确认
第二次握手：服务端收到一个SYN包，发送一个SYN+ACK包(seq=y),确认客户端的SYN包(ack=x+1)，此时服务器进入SYN_RCVD状态
第三次握手：客户端收到服务端的SYN+ACK包，向服务器发送ACK包(ack=y+1)，此包发送完毕，客户端和服务端进入ESTABLISHED状态
```



- #### 为什么要三次握手

  1. 为了初始化Sequcence Number的初始值
  2. 客户端和服务端都需要确认对方收发功能正常
  3. 防止延误的请求连接报文重新传回服务端建立连接

- #### 为什么要传回SYN

  为了告诉发送端自己收到的消息确实是对方发送的建立连接的信号

- #### SYN超时--洪范攻击

  问题的起因

  ```
  Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认。Server不断重试直至超时，Linux默认等待63秒才断开连接
  ```

  防护措施

  ```
  SYN队列满后，通过tcp_syncookies参数回发SYN Cookie，若为正常连接Client会回发SYN Cookie，直接建立连接
  ```

- #### 保活机制

  1. 向对方发送保活探测报文，如果未收到相应则继续发送

  2. 尝试此时达到保活探测数仍未收到相应则中断连接



### 2.4 TCP四次挥手

![img](assets/1641067-5ed8bf6c24244b4c.webp)

以Client端发起断开请求为例。

```
1.第一次挥手：Client发送一个FIN(seq=u)，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态
2.第二次挥手：Server接收FIN后，发送一个ACK给Client(seq=v, ack=u+1)，Server进入CLOSE_WAIT状态
3.第三次挥手：Server发送一个FIN(seq=w,ack=u+1)，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态
4.第四次挥手：Client接收到FIN后，Client进入TIME_WAIT状态，接着发送ACK给Server(seq=u+1,ack=w+1)，Server进入CLOSED状态，完成四次挥手
```



- #### 为什么会有TIME_WAIT状态

  1. 确保有足够的时间让对收到ACK
  2. 避免新旧连接混淆。2MSL可以确保当前连接产生的所有报文都从网络中消失，从而不会对新的复用IP和端口的连接造成干扰。

## 三 TCP的可靠传输

### 3.1 TCP如何实现可靠传输

- #### 校验

   TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

- #### 序号编号与确认

  TCP是面向字节的。TCP把应用层交下来的长报文（这可能要划分为许多较短的的报文段）看成是一个个字节组成的数据流，并使每一个字节对应于一个序号。

  TCP使用的是累计确认，确认号表示接收方期望下次收到的数据中的第一个数据字节序号。

- #### 重传

  **超时重传。**当TCP发送一段报文时，它同时也在自己的重传队列中存放这个报文段的一个副本。若收到确认，则删除此副本。若在规定时间内没有收到确认，则重传此报文段的副本。

  **快速重传。**当发送方连续收到三个重复的确认后，立即重传可能丢失的报文段。

- #### 流量控制

  TCP接收方要维护一个**接收窗口（rwnd）**的变量，其值不能大于可用接收缓存的大小，发送方的发送窗口大小不能大于接收窗口。以防止因发送发发送数据太快而导致接收方来不及接收，使接收方缓存溢出。

- #### 拥塞控制

  TCP发送方维持一个**拥塞窗口（cwnd）**的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且是动态变化的。发送方的发送窗口大小不能大于拥塞窗口，防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。

### 3.2 TCP的滑动窗口

TCP的滑动窗口主要要两个作用：一是提供TCP的**可靠性**，而是提供TCP的**流控特性**

TCP的滑动窗口是以字节为单位的

TCP窗口大小值是TCP报文头中一个16bit的字段，他带表窗口的字节容量。TCP窗口的最大值是2^16^ - 1=65535字节。

接受方确认报文段中的window字段表示接收方缓存中剩余的空间大小。



- #### 窗口构成

  **发送方**发送缓存内的数据可以分为四类：

  ![img](https://gitee.com/tongying003/MapDapot/raw/master/img/20200505180827.jpg)

  1. 已发送已确认
  2. 已发送未确认
  3. 未发送但允许发送
  4. 未发送且不允许发送

  **发送窗口 = 已发送未确认 + 未发送但允许发送**

  **可用窗口 = 未发送但允许发送**

  ![img](https://gitee.com/tongying003/MapDapot/raw/master/img/20200505180832)

  

  **接收方**接收缓存内的数据可以分为三类

  1. 已接收已发送ACK
  2. 未接收但是可以接收，即准备接收
  3. 未接受，并且不能接收

  ![1568638904222](https://gitee.com/tongying003/MapDapot/raw/master/img/20200505180838.png)

  ​	**接收窗口 = 未接受但是可以接收**





- #### 窗口滑动

  **发送窗口**只有在收到接收端对于本端发送窗口内字节的ACK确认，才会移送发送窗口的左边界

  ![img](https://gitee.com/tongying003/MapDapot/raw/master/img/20200505180843.jpg)

  ```
  当收到ACK=36时窗口滑动
  ```

  **接收窗口**只有在前面所有的段都确认的情况下才会移动左边界

  

- #### 发送窗口与接收窗口的关系

  TCP是双工的协议，会话的双方都可以同时接收、发送数据。TCP会话的双方都各自维护一个“发送窗口”和一个“接收窗口”。其中各自的“接收窗口”大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的“发送窗口”则要求取决于对端通告的“接收窗口”，要求相同。

  ![110345_b1h1_1469576.jpg](https://gitee.com/tongying003/MapDapot/raw/master/img/20200505180855.png)

- #### 滑动窗口实现面向流的可靠性

  1. 最基本的传输可靠性来源于**确认重传**机制
  2. TCP的滑动窗口的可靠性也是建立在确认重传基础上的
  3. 发送窗口只有收到对端对于本端发送窗口内字节的ACK确认，才会移动发送窗口的左边界
  4. 接收窗口只有在前面所有的段都确认的情况下才会移动左边界，当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不会对后续字节确认。以此确保对端会对这些数据重传。

- #### 滑动窗口的流控特性

  应用根据自身的处理能力变化，通过本端TCP接收窗口大小控制来对对对端的发送窗口流量进行限制。



### 3.2 TCP的流量控制

TCP为应用提供了**流量控制（Flow Control）服务**，以解决因发送方发送数据太快而导致接收方来不及接收，使接收方缓存溢出的问题。

TCP采用接收方控制发送方发送窗口大小的方法来实现在TCP连接上的流量控制。

TCP接收方要维护一个**接收窗口（rwnd）**的变量，其值不能大于可用接收缓存的大小，发送方的发送窗口大小不能大于接收窗口。



### 3.4 TCP的拥塞控制

为了进行拥塞控制，TCP发送方要为维持一个拥塞窗口（cwnd）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态变化。发送窗口 = min(cwnd，rwnd)。

TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

- #### 慢开始

  通常在刚开始发送报文段时，先把拥塞窗口cwnd设置为一个最大报文段MSS的值，每接收到一个对新报文段的确认后，拥塞窗口 cwnd 就加倍。

- #### 拥塞避免

  发送方的拥塞窗口每经过一个往返时延RTT就增加一个最大报文段MSS的大小。

​		TCP定义了一个状态变量，**慢开始门限ssthresh**，即从慢开始阶段进入拥塞避免阶段的门限。

```
(1) 当cwnd < ssthresh时，使用慢开始算法
(2) 当cwnd > ssthresh时，停止使用慢开始算法，改用拥塞避免算法
(3) 当cwnd = ssthresh时，既可以使用慢开始算法，也可以使用拥塞避免算法
```

无论是在慢开始阶段还是拥塞避免阶段，只要发送方发现出现网络拥塞（检测到分组丢失），就立即将拥塞窗口cwnd重新设置为1，并执行慢启动算法。这样做的目的时迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。在重新执行慢开始算算法的同时，将慢开始门限ssthresh设置为**出现拥塞时的发送窗口值的一半**（但不能小于2）

- #### 快重传与快恢复

  当发送方收到连续三个重复ACK时，虽然有可能丢失了一些分组，但这三个重复ACK同时又表明丢失分组以外的另外三个分组已经被接收方接受了，因此与发生超时事件的情况不同，网络还有一定的分组交付能力，拥塞情况并不严重，将拥塞窗口将为1有点过于粗暴了，这回导致发送方需要经过很长时间才能恢复到正常的传输速率。可以使用与**快重传**配套使用的**快恢复**算法。

  1. 当发送方连续接收到三个重复ACK时，重传分组，重新设置慢开始门限ssthresh为当前发送窗口的一半。
  2. 拥塞窗口不是设置为1，而是设置为新的慢开始门限ssthresh，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地线性增长。 

## 四 TCP与UDP的区别

1. 面向连接 vs 面向无连接
2. 面向报文 vs 面向字节流
3. 可靠交付 vs 尽最大努力交付
4. 首部开销大 （重）vs 首部开销小（轻）
5. 流量控制、拥塞控制 vs 无
6. 点对点 vs 多对多

## 五 在地址栏键入URL发生什么

### 4.1 显示主页的过程

1. DNS解析
2. 建立TCP连接
3. 发送HTTP请求
4. 服务器处理请求
5. 返回响应结果
6. 浏览器解析和渲染视图
7. 关闭TCP连接

### 4.2 DNS解析

![1566117438387](https://gitee.com/tongying003/MapDapot/raw/master/img/20200505180856.jpg)

以请求www.baidu.com为例

1. 先找本地host文件，检查是否有对应的域名、ip对应关系，若有则向ip地址发送请求，没有则取找DNS服务器
2. 客户端向本地DNS服务器发送DNS请求
3. 本地DNS服务器将请求转发到根DNS服务器
4. 根DNS服务器返回com DNS服务器的ip地址
5. 本地DNS服务器再次向com DNS发送查询请求
6. com DNS服务器返回baidu.com的解析服务器地址
7. 本地DNS服务器向解析服务器发送查询请求
8. 解析服务器返回含有www.baidu.com域名和ip的报文
9. 本地DNS服务器将ip地址返回给客户端，并将对应关系保存到缓存中

## 六 HTTP协议

### 6.1 HTTP报文格式

- #### 请求报文

  一个HTTP请求报文由以下四个部分组成

  1. ```
     请求行(request line)
     请求头(Header)
     空行
     请求数据
     ```

     ![HTTPè¯·æ±æ¥æ1](https://gitee.com/tongying003/MapDapot/raw/master/img/20200505180857.jpg)

  请求报文中常见的一些方法

  ```
  OPTION: 请求一些选项的信息
  GET: 请求URL标志的文档
  HEAD: 请求URL标志的文档的首部
  POST: 向服务器发送数据
  PUT: 在指明的URL下存储一个文档
  DELETE: 删除URL所标志的文档
  TRACE: 用来进行环回测试的情趣报文
  CONNECT: 用于代理服务器
  ```

  **HTTP Request Header**

  ```
  Accept:指客户端能接收的内容类型。如Accept:text/xml(application/json)表示希望接收到xml(json)类型
  Accept-Charset:浏览器可以接收的字符集编码
  Accept-Encoding:指定浏览器可以支持的Web服务器返回内容压缩编码类型
  Accept-Language:浏览器可接受的语言
  Cache-Control:指定请求和响应遵循的缓存机制
  Content-Length:请求的内容长度
  Content-Type:请求的与实体对应的MIME信息
  Host:指定请求的服务器的域名和端口号
  User-Agent:包含发出请求的用户信息
  ```

  **Content-Type**

  1. `text/html:` html格式
  2. `text/plain:`  纯文本格式
  3. `text/css:`  css格式
  4. `text/javascript:`  js格式
  5. `image/gif:` gif图片格式
  6. `image/jpeg:` jpg图片格式
  7. `image/png:` png图片格式
  8. `application/x-www-form-urlencoded:` POST专用，普通表单提交默认是这种方式。form表单被编码为key/value格式发送到服务器
  9. `application/json:` POST专用，用来告诉服务端消息主体是序列化后的JSON字符串
  10. `text/xml:` POST专用，发送xml数据
  11. `multipart/form-data:` POST专用，用以支持向服务器发送二进制数据，以便实现文件上传等功能

- #### 响应报文

  一个http响应报文通常由以下几个部分构成

  ```
  状态行
  响应头部
  空行
  响应主体
  ```

  ![img](https://gitee.com/tongying003/MapDapot/raw/master/img/20200505180858.png)

**状态码**

```
1xx: 表示通知信息的，如请求收到了或正在处理
2xx: 表示成功，如接受或知道了
3XX: 表示重定向，表示要完成请求必须采取进一步的行动
4XX: 表示客户端错误，如请求中有错误的语法或不能完成
5xx: 表示服务器的差错，如服务器失效无法完成请求
```

**常见状态码**

1. `200 OK：`正常返回信息
2. `400 Bad Request：`客户端请求与语法错误，不能被服务器所理解
3. `401 Unauthorized：`请求未经授权，这个状态码必须与WWW-Authenticate报头域一起使用
4. `403 Forbidden：`服务器收到请求，但是拒绝提供服务
5. `404 Not Found：`请求资源不存在，eg，输入了错误的url
6. `500 Internal Server Error：`服务器发生了不可预期的错误
7. `503 Server Unavailable：`服务器当前不能处理客户端的请求，一段时间后可能恢复正常

### 6.2 Post和Get的区别

1. **HTTP报文层面：**GET将请求信息放在URL中，POST放在报文体中

2. **数据库层面：**GET请求符合幂等性和安全性，POST不符合

   ```
   幂等性：对数据库的一次操作和多次操作获得的结果是一致的
   安全性：对数据库的请求 没有改变数据库中的数据
   ```

3. **其他层面：**GET可以被缓存、被存储，而POST不行

   ```
   GET请求会保存在浏览器的浏览记录中，GET请求的URL可以保存为浏览器书签
   绝大多数GET请求都被CDN缓存，大大减小WEB服务器的负担
   ```

### 6.3 Cookie和Session的区别

- #### Cookie简介

  1. Cookie是由服务器发送个客户端的特殊信息，以文本的形式存放在客户端

  2. 客户端再次请求的时候，会把Cookie回发
  3. 服务器接收到后，会解析Cookie生成与客户端相对应的内容

- #### Cookie的设置及发送过程

  ![img](assets/13949989-dcf024be2733e725-1568718389763.webp)

- #### Session简介

  1. 服务器端的机制，在服务器上保存的信息
  2. 解析客户端请求并操作session id，按需保存状态信息

- #### Session的实现方式

  1. 使用Cookie来实现

     ![1568718810108](https://gitee.com/tongying003/MapDapot/raw/master/img/20200505180859.png)

  2. 使用URL回写来实现

     服务器在发送给浏览器页面所有链接中都携带JSESSIONID，客户端点击任何链接都会把JSESSIONID带回服务器

  Tomcat对Session的实现方式是一开始同时使用Cookie和URL回写，如果浏览器支持Cookie，则使用Cookie来实现，停止使用URL回写，否则一直用URL回写来实现。

- #### Cookie和Session的区别

  1. Cookie数据存放在客户端的浏览器上，Session数据存放在服务器上
  2. Session相对于Cookie更安全
  3. 若考虑减轻服务器负担，应当使用Cookie



### 6.4 HTTPS

- #### SSL简介

  1. 为网络通信提供安全及数据完整性的一种安全协议
  2. 是操作系统对外提供的API，SSL3.0以后更名为TLS
  3. 采用身份验证和数据加密保证网络通信的安全和数据的完整性

- #### SSL/TLS握手过程

  1. 由客户端发送连接请求，将支持的协议版本、加密算法、压缩算法以及一个随机数random1发送给服务器

  2. 服务器确认使用的加密协议版本和加密方法，生成一个随机数random2，和证书一起回发给客户端

  3. 客户端验证证书的合法性，生成一个随机数random3，也叫做`pre-master key`，用公钥加密后发送给服务器

  4. 服务器用私钥解密出第三个随机数`pre-master key`，计算生成本次会话所用的会话密钥，加密一条消息回发给客户端

  5. 浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据

     ```
     为什么要三个随机数？
     SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre-master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，那么客户端和服务器加上pre-master secret三个随机数一同生成的密钥就不容易被猜出了
     ```



### 6.5 HTTP长短连接

- #### HTTP长连接

  而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

  ```
  Connection:keep-alive
  ```

  在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。

  

- #### 一个TCP连接中请求发送可以一起发送吗？

  1. HTTP/1.1:单个TCP连接在同一时刻只能处理一个请求，Pipelining可以在一个TCP连接中发送多个HTTP请求，收到请求的服务器必须按照请求收到的顺序发送响应，同时返回的话并不能区分对应于哪个请求的响应。实践有些困难，浏览器默认不开启。
  2. HTTP2:Multiplexing多路传输。

- #### HTML中多个图片，怎么下载的？

  1.如果图片都是HTTPS连接并且在同一域名下，那么浏览器在SSL握手之后会和浏览器商量能不能用HTTP2，如果能的话就用Multiplexiing功能在这个连接上进行多路传输。
  2.发现不了HTTP2或者用不了HTTPS(现实中的HTTP2都是在HTTPS上实现的)，浏览器会在一个HOST上建立多个TCP链接，连接数量的最大限制取决于浏览器设置。
